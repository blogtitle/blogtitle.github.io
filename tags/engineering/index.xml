<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>engineering on Blog Title</title>
    <link>https://blogtitle.github.io/tags/engineering/</link>
    <description>Recent content in engineering on Blog Title</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 Dec 2019 20:07:04 +0100</lastBuildDate>
    
	<atom:link href="https://blogtitle.github.io/tags/engineering/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go advanced concurrency patterns: part 3 (channels)</title>
      <link>https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/</link>
      <pubDate>Thu, 05 Dec 2019 20:07:04 +0100</pubDate>
      
      <guid>https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/</guid>
      <description>Today I&amp;rsquo;m going to dive into the expressive power of Go channels and the select statement. To demonstrate how much can be implemented with just those two primitives I will rewrite the sync package from scratch.
In doing so I&amp;rsquo;m just going to accept some compromises:
 This post is about expressive power, not speed. The examples will correctly express the primitives but might not be as fast as the real ones.</description>
    </item>
    
    <item>
      <title>Using JavaScript SharedArrayBuffers and Atomics</title>
      <link>https://blogtitle.github.io/using-javascript-sharedarraybuffers-and-atomics/</link>
      <pubDate>Fri, 22 Mar 2019 12:42:05 +0100</pubDate>
      
      <guid>https://blogtitle.github.io/using-javascript-sharedarraybuffers-and-atomics/</guid>
      <description>I&amp;rsquo;m not a big fan of JavaScript but I like parallel programming and JS has some interesting concepts of it.
In addition to the event loop I&amp;rsquo;ve recently got to know the concept of Web Workers. They are real threads that execute in parallel with the main thread, and are allowed to wait and block as much as they want.
Modern devices are going in the direction of having a lot of FPS and web developers want to maintain the user experience smooth.</description>
    </item>
    
    <item>
      <title>Go advanced concurrency patterns: part 2 (timers)</title>
      <link>https://blogtitle.github.io/go-advanced-concurrency-patterns-part-2-timers/</link>
      <pubDate>Mon, 25 Feb 2019 22:56:23 +0100</pubDate>
      
      <guid>https://blogtitle.github.io/go-advanced-concurrency-patterns-part-2-timers/</guid>
      <description>As I stated in my previous article timers are hard to use the right way so here are some handful tips.
Preface If you don&amp;rsquo;t think dealing with time and timers while also juggling goroutines is hard, here are some juicy bugs related to time.Timer:
 time: Timer.Reset is not possible to use correctly #14038 time: Timer.C can still trigger even after Timer.Reset is called #11513 time: document proper usage of Timer.</description>
    </item>
    
    <item>
      <title>Go advanced concurrency patterns: part 1</title>
      <link>https://blogtitle.github.io/go-advanced-concurrency-patterns-part-1/</link>
      <pubDate>Sat, 23 Feb 2019 09:47:23 +0100</pubDate>
      
      <guid>https://blogtitle.github.io/go-advanced-concurrency-patterns-part-1/</guid>
      <description>Writing code is hard. Writing code that has to deal with parallelism and concurrency is harder. Doing all of that an keeping it efficient is challenging.
Today I decided to start sharing a couple of tricks to handle some peculiar cases.
Timed channels operations Sometimes you want to time your channels operations: keep trying to do something, and if you can&amp;rsquo;t do it in time just drop the ball.</description>
    </item>
    
  </channel>
</rss>