<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rust on Blog Title</title>
    <link>https://blogtitle.github.io/tags/rust/</link>
    <description>Recent content in rust on Blog Title</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 Dec 2019 09:33:58 +0100</lastBuildDate>
    
	<atom:link href="https://blogtitle.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Sneaky race conditions and granular locks</title>
      <link>https://blogtitle.github.io/sneaky-race-conditions-and-granular-locks/</link>
      <pubDate>Wed, 11 Dec 2019 09:33:58 +0100</pubDate>
      
      <guid>https://blogtitle.github.io/sneaky-race-conditions-and-granular-locks/</guid>
      <description>Race conditions are the main problem you have to care about when writing concurrent code. Go provides high level primitives that make it easier to get concurrency and parallelism right, but those are often times not enough.
This is one of the reasons why Go has a race detector. You should always run your tests and, where possible, a portion of your production fleet with -race enabled. Beware that this might still not be enough: the detector only triggers when a race manifests and not all races are detected by it.</description>
    </item>
    
  </channel>
</rss>